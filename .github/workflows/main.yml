name: Gigafile XGF Explorer Lite

on:
  schedule:
    - cron: '*/3 * * * *'  # 3分ごとに実行
  workflow_dispatch:  # 手動実行用

jobs:
  explore:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '6.0.x'

      - name: Create XGF Explorer Script
        run: |
          cat > XgfExplorer.cs << 'EOL'
          using System;
          using System.Net.Http;
          using System.Threading.Tasks;
          using System.Text.RegularExpressions;
          using System.Collections.Generic;
          using System.IO;
          using System.Linq;

          class Program
          {
              private static readonly HttpClient client = new HttpClient();
              private static readonly string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
              private static readonly Random random = new Random();
              private static readonly string baseUrl = "https://xgf.nu/";
              private static readonly string resultFile = "found_files.txt";
              private static readonly HashSet<string> existingCodes = new HashSet<string>();
              private const int MAX_ATTEMPTS = 50; // 1回の実行で試行する数を50に制限
              private const int BATCH_SIZE = 5; // 同時実行数を5に制限
              private static readonly TimeSpan MAX_RUNTIME = TimeSpan.FromMinutes(2); // 最大実行時間を2分に制限

              static async Task Main()
              {
                  var startTime = DateTime.UtcNow;
                  LoadExistingCodes();
                  
                  var foundFiles = new List<string>();
                  var processedCount = 0;
                  
                  Console.WriteLine($"Starting exploration at {startTime:yyyy-MM-dd HH:mm:ss UTC}");
                  
                  while (processedCount < MAX_ATTEMPTS && DateTime.UtcNow - startTime < MAX_RUNTIME)
                  {
                      var batchTasks = new List<Task>();
                      var batchSize = Math.Min(BATCH_SIZE, MAX_ATTEMPTS - processedCount);
                      
                      for (int i = 0; i < batchSize; i++)
                      {
                          var code = GenerateUniqueCode();
                          if (code != null)
                          {
                              batchTasks.Add(ProcessCode(code, foundFiles));
                              processedCount++;
                          }
                      }
                      
                      await Task.WhenAll(batchTasks);
                      await Task.Delay(1000); // 1秒待機
                  }

                  var endTime = DateTime.UtcNow;
                  Console.WriteLine($"Exploration completed at {endTime:yyyy-MM-dd HH:mm:ss UTC}");
                  Console.WriteLine($"Total runtime: {(endTime - startTime).TotalSeconds:F1} seconds");
                  
                  await SaveResults(foundFiles);
                  
                  if (foundFiles.Count > 0)
                  {
                      var output = string.Join("\n", foundFiles);
                      Console.WriteLine($"::set-output name=found_files::{output}");
                      Console.WriteLine($"::set-output name=found_count::{foundFiles.Count}");
                  }
              }

              static void LoadExistingCodes()
              {
                  if (File.Exists(resultFile))
                  {
                      foreach (var line in File.ReadLines(resultFile))
                      {
                          var code = line.Split('|')[0].Trim();
                          existingCodes.Add(code);
                      }
                      Console.WriteLine($"Loaded {existingCodes.Count} existing codes");
                  }
              }

              static string GenerateUniqueCode()
              {
                  for (int i = 0; i < 10; i++)
                  {
                      var code = new string(Enumerable.Range(0, 4)
                          .Select(_ => chars[random.Next(chars.Length)])
                          .ToArray());
                      
                      if (!existingCodes.Contains(code))
                      {
                          existingCodes.Add(code);
                          return code;
                      }
                  }
                  return null;
              }

              static async Task ProcessCode(string code, List<string> foundFiles)
              {
                  try
                  {
                      var result = await CheckUrl(code);
                      if (result.exists)
                      {
                          var fileInfo = $"{code} | {result.filename} | {result.size:N0} bytes | {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss}";
                          lock (foundFiles)
                          {
                              foundFiles.Add(fileInfo);
                              Console.WriteLine($"[FOUND] {fileInfo}");
                          }
                      }
                  }
                  catch (Exception ex)
                  {
                      Console.WriteLine($"Error checking {code}: {ex.Message}");
                  }
              }

              static async Task<(bool exists, string filename, long size)> CheckUrl(string code)
              {
                  using var request = new HttpRequestMessage(HttpMethod.Head, baseUrl + code);
                  request.Headers.Add("User-Agent", "GitHub-Actions-XGF-Explorer-Lite");
                  
                  using var response = await client.SendAsync(request);
                  
                  if (response.RequestMessage.RequestUri.Host == "gigafile.nu")
                  {
                      using var fileResponse = await client.SendAsync(new HttpRequestMessage(HttpMethod.Head, response.RequestMessage.RequestUri));
                      var contentDisposition = fileResponse.Headers.Contains("Content-Disposition") 
                          ? fileResponse.Headers.GetValues("Content-Disposition").FirstOrDefault() 
                          : null;
                      
                      if (!string.IsNullOrEmpty(contentDisposition))
                      {
                          var match = Regex.Match(contentDisposition, @"filename[^;=\n]*=((['""]).*?\2|[^;\n]*)");
                          var filename = match.Success ? match.Groups[1].Value.Trim('"') : "unknown";
                          var size = fileResponse.Content.Headers.ContentLength ?? 0;
                          
                          if (filename.EndsWith(".txt", StringComparison.OrdinalIgnoreCase))
                          {
                              return (true, filename, size);
                          }
                      }
                  }
                  
                  return (false, string.Empty, 0);
              }

              static async Task SaveResults(List<string> foundFiles)
              {
                  if (foundFiles.Count > 0)
                  {
                      var newContent = new List<string>();
                      
                      if (File.Exists(resultFile))
                      {
                          newContent.AddRange(File.ReadLines(resultFile));
                      }
                      
                      newContent.AddRange(foundFiles);
                      newContent = newContent.Distinct().OrderBy(x => x).ToList();
                      
                      await File.WriteAllLinesAsync(resultFile, newContent);
                      Console.WriteLine($"Updated results file. Total entries: {newContent.Count}");
                  }
              }
          }
          EOL

      - name: Compile and Run Explorer
        id: explore
        run: |
          dotnet new console
          mv XgfExplorer.cs Program.cs
          dotnet build
          dotnet run

      - name: Commit and Push Results
        if: success()
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          if [ -f found_files.txt ]; then
            git add found_files.txt
            git commit -m "Update found files: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" || echo "No changes to commit"
            git push
          fi

      - name: Create Issue for New Findings
        if: steps.explore.outputs.found_count > 0
        uses: actions/github-script@v6
        with:
          script: |
            const foundCount = process.env.FOUND_COUNT;
            const foundFiles = process.env.FOUND_FILES;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[XGF Explorer] Found ${foundCount} TXT Files - ${new Date().toISOString()}`,
              body: `New TXT files found:\n\`\`\`\n${foundFiles}\n\`\`\``
            });
        env:
          FOUND_COUNT: ${{ steps.explore.outputs.found_count }}
          FOUND_FILES: ${{ steps.explore.outputs.found_files }}

permissions:
  contents: write
  issues: write
